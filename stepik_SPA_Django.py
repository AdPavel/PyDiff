# На вход подается список чисел и целевое число на отдельной строке. Верните индексы двух чисел, которые в сумме дают
# целевое число.
# Любые входные данные имеют только 1 решение и один и тот же элемент списка не нужно использовать дважды.
# Индексы можно вернуть в любом порядке.
#
# ls = [int(x) for x in input().split(',')]
# y = int(input())
#
# for i in range(len(ls)):
#     for j in range(i):
#         if ls[i] + ls[j] == y:
#             print(i, j)

#========================
# Напишите программу, которая находит самый длинный общий префикс для строк находящихся в списке строк
# Sample Input: flower,flow,flight
# Sample Output: fl
#
# import os
# print(os.path.commonprefix(input().split(',')))

#===========================================================================
# Римские цифры представлены семью различными символами: I, V, X, L, C, D и M.
# I             1
# V             5
# X             10
# L             50
# C             100
# D             500
# M             1000
# Например, 2 пишется как II в римскими цифрами, просто две единицы сложенных вместе. 12 записывается как XII,
# то есть просто X + II. Число 27 записывается как XXVII, то есть XX + V + II.
# Римские цифры обычно пишутся от наибольшего к наименьшему слева направо. Однако цифра четыре-это не IIII. Вместо
# этого число четыре записывается как IV. Поскольку единица стоит перед пятью, мы вычитаем ее, и получится четыре.
# Тот же принцип применим и к числу девять, которое записывается как IX. Есть шесть случаев, когда используется вычитание:
# I может быть помещен перед V (5) и X (10), чтобы сделать 4 и 9.
# X может быть помещен перед L (50) и C (100), чтобы сделать 40 и 90.
# C может быть помещен перед D (500) и M (1000), чтобы сделать 400 и 900.
# Дана римская цифра, преобразуйте ее в целое число.

# def solution(roman):
#     romanNumeralMap = (('M', 1000),
#                        ('CM', 900),
#                        ('D', 500),
#                        ('CD', 400),
#                        ('C', 100),
#                        ('XC', 90),
#                        ('L', 50),
#                        ('XL', 40),
#                        ('X', 10),
#                        ('IX', 9),
#                        ('V', 5),
#                        ('IV', 4),
#                        ('I', 1))
#     result = 0
#     index = 0
#     for numeral, integer in romanNumeralMap:
#         while roman[index:index + len(numeral)] == numeral:
#             result += integer
#             index += len(numeral)
#     return result

# print(solution(input()))

#================================================================================
# Дано 32-битное целое число x, верните x развернув в обратную сторону. Если реверсирование x приводит к выходу
# значения за пределы 32-битного целочисленного диапазона со знаком [-231, 231-1], то верните 0.
#
# Ограничения: -2**31 <= x <= 2**31-1

# x = str(input())
# if x[0] == '-':
#     x = int(x[0] + x[:0:-1])
# else:
#     x = int(x[::-1])
#
# print(x if -2**31 <= x <= 2**31-1 else 0)

#========================== polindrom ==================================================
# Дано целое число x, верните true, если x является палиндромом.
# Целое число является палиндромом, когда оно читается слева направо так же как и справа налево. Например,
# 121 - это палиндром, а 123-нет.
# Ограничения: -2**31 <= x <= 2**31-1
# def ispolindrom(x):
#     # if x[0] == '-':
#     #     rev_x = int(x[0] + x[:0:-1])
#     # else:
#     #     rev_x = int(x[::-1])
#
#     return x == x[::-1] and (-2**31 <= int(x) <= 2**31-1)
#
# print(ispolindrom(str(input())))

#================================================================================
# Дана строка s содержащая только символы '(', ')', '{', '}', '[' и ']', определите, является ли входная строка валидной.
# Входная строка допустима, если:
# Открытые скобки должны быть закрыты скобками того же типа.
# Открытые скобки должны быть закрыты в правильном порядке.

# s = input()
# ls = ['()', '{}', '[]']
# for sym in range(len(list(ls))):
#     for pair in ls:
#         s = s.replace(pair, '')
#
# print(True if len(s) == 0 else False)

#==============================
# s = input().split()
# print(len(s[-1]) if len(s) else 0)

#===================
# Даны 2 двоичных числа. Верните их сумму в двоичной системе счисления.
# a = int(input(), 2)
# b = int(input(), 2)
# print(f'{a + b:b}')

#===================
# Верните корень данного числа x.
# Важно, верните только целую часть корня. Например корень из 8 = 2.82842... Правильным ответом для этого числа будет 2

# import math
#
# print(int(math.sqrt(int(input()))))

#===============================
# Вам дан массив цен price, где price[i] цена на i+1 день.
# Вы хотите увеличить вашу выгоду выбрав один день чтобы купить акцию и выбрать один день в будущем чтобы ее продать.
# Верните максимальную выгоду. Если вы не можете получить выгоду, то верните 0.
# Например дан массив цен [7,1,5,3,6,4]. Покупая на второй день по цене 1, вы можете выгодно продать акцию на  5 день
# по цене 6. 6 - 1 = выгода равна 5.

# price = [int(i) for i in input().split(',')]
# idx_min = price.index(min(price))
# max_price = max(price[idx_min:])
# print(max_price - min(price))

